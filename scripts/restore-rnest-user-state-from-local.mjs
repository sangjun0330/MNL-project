#!/usr/bin/env node

import fs from "node:fs";
import path from "node:path";

const SOURCE_DIR = process.env.RNEST_LOCAL_USER_STATE_DIR || ".rnest_users";
const OUTPUT_SQL =
  process.env.RNEST_RESTORE_SQL_OUTPUT || "supabase/manual/restore_rnest_user_state_from_local.sql";

function isObject(value) {
  return typeof value === "object" && value !== null;
}

function toIso(updatedAt) {
  if (typeof updatedAt === "number" && Number.isFinite(updatedAt)) {
    return new Date(updatedAt).toISOString();
  }
  if (typeof updatedAt === "string" && updatedAt.trim()) {
    const date = new Date(updatedAt);
    if (!Number.isNaN(date.getTime())) return date.toISOString();
  }
  return new Date().toISOString();
}

function sqlString(value) {
  return `'${String(value).replace(/'/g, "''")}'`;
}

function readStateFiles(dir) {
  if (!fs.existsSync(dir)) return [];
  const out = [];
  const stack = [dir];
  while (stack.length) {
    const current = stack.pop();
    if (!current) continue;
    const entries = fs.readdirSync(current, { withFileTypes: true });
    for (const entry of entries) {
      const next = path.join(current, entry.name);
      if (entry.isDirectory()) {
        stack.push(next);
        continue;
      }
      if (entry.isFile() && entry.name === "state.json") {
        out.push(next);
      }
    }
  }
  return out.sort();
}

// MEDIUM-2: SQL 인젝션 방지 — userId 형식 검증
// Supabase auth.users.id는 UUID 형식이거나 provider:email 형식
const VALID_UUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
const VALID_PROVIDER_ID = /^[a-zA-Z0-9_-]{1,32}:[a-zA-Z0-9._%+\-]{1,64}@[a-zA-Z0-9.\-]{1,64}\.[a-zA-Z]{2,}$/;

function isValidUserId(userId) {
  const str = String(userId ?? "").trim();
  if (!str || str.length > 320) return false;
  return VALID_UUID.test(str) || VALID_PROVIDER_ID.test(str);
}

function parseStateFile(filePath) {
  const raw = fs.readFileSync(filePath, "utf8");
  const json = JSON.parse(raw);
  if (!isObject(json)) return null;
  if (!json.userId || !json.payload) return null;
  const userId = String(json.userId);
  if (!isValidUserId(userId)) {
    console.warn(`[warn] invalid userId format, skipping: ${filePath} (userId: ${userId.slice(0, 60)})`);
    return null;
  }
  return {
    userId,
    payload: json.payload,
    updatedAt: toIso(json.updatedAt),
    source: filePath,
  };
}

function buildSql(records) {
  const lines = [];
  lines.push("-- Generated by scripts/restore-rnest-user-state-from-local.mjs");
  lines.push("-- Purpose: restore rnest_user_state rows from local backup files (.rnest_users/**/state.json)");
  lines.push(`-- Generated at: ${new Date().toISOString()}`);
  lines.push("");
  lines.push("begin;");
  lines.push("");

  if (!records.length) {
    lines.push("-- No local state files found.");
    lines.push("commit;");
    return `${lines.join("\n")}\n`;
  }

  for (const record of records) {
    const payloadJson = JSON.stringify(record.payload).replace(/'/g, "''");
    lines.push(`-- source: ${record.source}`);
    lines.push(
      `insert into public.rnest_user_state (user_id, payload, updated_at) values (${sqlString(
        record.userId
      )}, '${payloadJson}'::jsonb, ${sqlString(record.updatedAt)}::timestamptz)`
    );
    lines.push("on conflict (user_id) do update");
    lines.push("set");
    lines.push("  payload = excluded.payload,");
    lines.push("  updated_at = excluded.updated_at");
    lines.push("where");
    lines.push("  public.rnest_user_state.updated_at is null");
    lines.push(
      "  or excluded.updated_at >= public.rnest_user_state.updated_at;"
    );
    lines.push("");
  }

  lines.push("commit;");
  return `${lines.join("\n")}\n`;
}

function main() {
  const files = readStateFiles(SOURCE_DIR);
  const parsed = files
    .map((file) => {
      try {
        return parseStateFile(file);
      } catch (error) {
        return {
          _error: true,
          source: file,
          message: error instanceof Error ? error.message : String(error),
        };
      }
    })
    .filter(Boolean);

  const invalid = parsed.filter((row) => row?._error);
  const valid = parsed.filter((row) => !row?._error);

  const sql = buildSql(valid);
  fs.mkdirSync(path.dirname(OUTPUT_SQL), { recursive: true });
  fs.writeFileSync(OUTPUT_SQL, sql, "utf8");

  if (invalid.length) {
    for (const row of invalid) {
      console.warn(`[warn] failed to parse ${row.source}: ${row.message}`);
    }
  }

  console.log(`[done] source files: ${files.length}`);
  console.log(`[done] valid records: ${valid.length}`);
  console.log(`[done] output sql: ${OUTPUT_SQL}`);
}

main();
