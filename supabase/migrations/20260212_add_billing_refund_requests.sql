create table if not exists public.billing_refund_requests (
  id bigint generated by default as identity primary key,
  user_id text not null,
  order_id text not null,
  reason text not null,
  status text not null default 'PENDING',
  admin_note text,
  requested_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  notified_at timestamptz
);

create index if not exists idx_billing_refund_requests_user_requested_at
  on public.billing_refund_requests (user_id, requested_at desc);

create unique index if not exists ux_billing_refund_requests_pending_order
  on public.billing_refund_requests (user_id, order_id)
  where status = 'PENDING';

do $$
begin
  if not exists (
    select 1
    from pg_constraint
    where conname = 'billing_refund_requests_status_check'
  ) then
    alter table public.billing_refund_requests
      add constraint billing_refund_requests_status_check
      check (status in ('PENDING', 'APPROVED', 'REJECTED', 'CANCELED'));
  end if;
end
$$;

alter table public.billing_refund_requests enable row level security;

drop policy if exists "billing_refund_requests_select_own" on public.billing_refund_requests;
drop policy if exists "billing_refund_requests_insert_own" on public.billing_refund_requests;

create policy "billing_refund_requests_select_own"
  on public.billing_refund_requests
  for select
  to authenticated
  using ((select auth.uid())::text = user_id);

create policy "billing_refund_requests_insert_own"
  on public.billing_refund_requests
  for insert
  to authenticated
  with check ((select auth.uid())::text = user_id);
