create table if not exists public.billing_refund_requests (
  id bigint generated by default as identity primary key,
  user_id text not null,
  order_id text not null,
  reason text not null,
  status text not null default 'REQUESTED',
  admin_note text,
  requested_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  notified_at timestamptz
);

alter table public.billing_refund_requests
  add column if not exists reviewed_by text,
  add column if not exists reviewed_at timestamptz,
  add column if not exists review_note text,
  add column if not exists executed_by text,
  add column if not exists executed_at timestamptz,
  add column if not exists cancel_amount integer,
  add column if not exists currency text default 'KRW',
  add column if not exists toss_payment_key_snapshot text,
  add column if not exists toss_cancel_transaction_key text,
  add column if not exists gateway_response jsonb,
  add column if not exists error_code text,
  add column if not exists error_message text,
  add column if not exists retry_count integer not null default 0,
  add column if not exists next_retry_at timestamptz,
  add column if not exists notify_user_sent_at timestamptz;

update public.billing_refund_requests
set
  status = 'REQUESTED',
  currency = coalesce(currency, 'KRW'),
  cancel_amount = coalesce(cancel_amount, 0)
where status = 'PENDING';

update public.billing_refund_requests
set currency = 'KRW'
where currency is null;

alter table public.billing_refund_requests
  alter column currency set not null;

alter table public.billing_refund_requests enable row level security;

drop policy if exists "billing_refund_requests_select_own" on public.billing_refund_requests;
drop policy if exists "billing_refund_requests_insert_own" on public.billing_refund_requests;

create policy "billing_refund_requests_select_own"
  on public.billing_refund_requests
  for select
  to authenticated
  using ((select auth.uid())::text = user_id);

create policy "billing_refund_requests_insert_own"
  on public.billing_refund_requests
  for insert
  to authenticated
  with check ((select auth.uid())::text = user_id);

drop index if exists ux_billing_refund_requests_pending_order;

create unique index if not exists ux_billing_refund_requests_open_order
  on public.billing_refund_requests (user_id, order_id)
  where status in ('REQUESTED', 'UNDER_REVIEW', 'APPROVED', 'EXECUTING', 'FAILED_RETRYABLE');

do $$
begin
  if exists (
    select 1
    from pg_constraint
    where conname = 'billing_refund_requests_status_check'
  ) then
    alter table public.billing_refund_requests
      drop constraint billing_refund_requests_status_check;
  end if;
end
$$;

alter table public.billing_refund_requests
  add constraint billing_refund_requests_status_check
  check (
    status in (
      'REQUESTED',
      'UNDER_REVIEW',
      'APPROVED',
      'REJECTED',
      'EXECUTING',
      'REFUNDED',
      'FAILED_RETRYABLE',
      'FAILED_FINAL',
      'WITHDRAWN'
    )
  );

create table if not exists public.billing_refund_events (
  id bigint generated by default as identity primary key,
  request_id bigint not null references public.billing_refund_requests(id) on delete cascade,
  user_id text not null,
  order_id text not null,
  actor_user_id text,
  actor_role text not null default 'system',
  event_type text not null,
  from_status text,
  to_status text,
  message text,
  metadata jsonb,
  created_at timestamptz not null default now()
);

create index if not exists idx_billing_refund_events_request_created
  on public.billing_refund_events (request_id, created_at desc);

create index if not exists idx_billing_refund_events_user_created
  on public.billing_refund_events (user_id, created_at desc);

do $$
begin
  if not exists (
    select 1
    from pg_constraint
    where conname = 'billing_refund_events_actor_role_check'
  ) then
    alter table public.billing_refund_events
      add constraint billing_refund_events_actor_role_check
      check (actor_role in ('user', 'admin', 'system'));
  end if;
end
$$;

alter table public.billing_refund_events enable row level security;

drop policy if exists "billing_refund_events_select_own" on public.billing_refund_events;

create policy "billing_refund_events_select_own"
  on public.billing_refund_events
  for select
  to authenticated
  using ((select auth.uid())::text = user_id);

select pg_notify('pgrst', 'reload schema');
