-- RNest Supabase full reset + clean rebuild (V2)
-- WARNING: This migration deletes all data in RNest application tables.
-- Scope: user profile/state, ai content, billing orders/refunds, legacy daily logs.

begin;

-- 0) Cleanup: views/functions/triggers/tables
drop view if exists public.v_user_data_overview;
drop view if exists public.v_user_billing_summary;
drop view if exists public.v_user_credit_live;

drop trigger if exists trg_set_updated_at_rnest_users on public.rnest_users;
drop trigger if exists trg_set_updated_at_rnest_user_state on public.rnest_user_state;
drop trigger if exists trg_set_updated_at_ai_content on public.ai_content;
drop trigger if exists trg_set_updated_at_billing_orders on public.billing_orders;
drop trigger if exists trg_set_updated_at_refund_requests on public.billing_refund_requests;
drop trigger if exists trg_log_rnest_user_state_revision on public.rnest_user_state;

drop function if exists public.tg_set_updated_at();
drop function if exists public.tg_log_rnest_user_state_revision();

drop table if exists public.med_safety_usage_events cascade;
drop table if exists public.rnest_user_state_revisions cascade;
drop table if exists public.billing_refund_events cascade;
drop table if exists public.billing_refund_requests cascade;
drop table if exists public.billing_orders cascade;
drop table if exists public.ai_content cascade;
drop table if exists public.rnest_user_state cascade;
drop table if exists public.rnest_users cascade;
drop table if exists public.rnest_daily_logs cascade;

-- 1) Core user table
create table public.rnest_users (
  user_id text primary key,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  last_seen timestamptz not null default now(),
  subscription_tier text not null default 'free',
  subscription_status text not null default 'inactive',
  subscription_started_at timestamptz,
  subscription_current_period_end timestamptz,
  subscription_updated_at timestamptz,
  subscription_cancel_at_period_end boolean not null default false,
  subscription_cancel_scheduled_at timestamptz,
  subscription_canceled_at timestamptz,
  subscription_cancel_reason text,
  toss_customer_key text,
  toss_last_order_id text,
  med_safety_extra_credits integer not null default 0,
  med_safety_daily_used integer not null default 0,
  med_safety_usage_date date,
  constraint rnest_users_subscription_tier_check
    check (subscription_tier in ('free', 'pro')),
  constraint rnest_users_subscription_status_check
    check (subscription_status in ('inactive', 'active', 'expired')),
  constraint rnest_users_med_safety_extra_credits_nonnegative
    check (med_safety_extra_credits >= 0),
  constraint rnest_users_med_safety_daily_used_nonnegative
    check (med_safety_daily_used >= 0)
);

-- 2) User state snapshot (single latest state per user)
create table public.rnest_user_state (
  user_id text primary key references public.rnest_users(user_id) on delete cascade,
  payload jsonb not null default '{}'::jsonb,
  updated_at timestamptz not null default now(),
  constraint rnest_user_state_payload_object_check
    check (jsonb_typeof(payload) = 'object')
);

-- 3) User state revisions (append-only audit trail for restore/debug)
create table public.rnest_user_state_revisions (
  id bigint generated by default as identity primary key,
  user_id text not null references public.rnest_users(user_id) on delete cascade,
  payload jsonb not null,
  source text not null default 'api',
  created_at timestamptz not null default now(),
  constraint rnest_user_state_revisions_payload_object_check
    check (jsonb_typeof(payload) = 'object')
);

-- 4) AI result cache per user
create table public.ai_content (
  user_id text primary key references public.rnest_users(user_id) on delete cascade,
  date_iso text not null,
  language text not null default 'ko',
  data jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint ai_content_language_check
    check (language in ('ko', 'en')),
  constraint ai_content_data_object_check
    check (jsonb_typeof(data) = 'object')
);

-- 5) Billing orders (subscription + credit pack)
create table public.billing_orders (
  order_id text primary key,
  user_id text not null references public.rnest_users(user_id) on delete cascade,
  plan_tier text not null,
  order_kind text not null default 'subscription',
  credit_pack_units integer not null default 0,
  amount integer not null,
  currency text not null default 'KRW',
  status text not null default 'READY',
  order_name text not null,
  payment_key text,
  fail_code text,
  fail_message text,
  toss_response jsonb,
  approved_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint billing_orders_status_check
    check (status in ('READY', 'DONE', 'FAILED', 'CANCELED')),
  constraint billing_orders_plan_tier_check
    check (plan_tier in ('free', 'pro')),
  constraint billing_orders_order_kind_check
    check (order_kind in ('subscription', 'credit_pack')),
  constraint billing_orders_credit_pack_units_nonnegative
    check (credit_pack_units >= 0),
  constraint billing_orders_credit_pack_units_consistency_check
    check (
      (order_kind = 'subscription' and credit_pack_units = 0)
      or
      (order_kind = 'credit_pack' and credit_pack_units > 0)
    )
);

-- 6) Billing refund requests
create table public.billing_refund_requests (
  id bigint generated by default as identity primary key,
  user_id text not null references public.rnest_users(user_id) on delete cascade,
  order_id text not null references public.billing_orders(order_id) on delete cascade,
  reason text not null,
  status text not null default 'REQUESTED',
  admin_note text,
  requested_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  notified_at timestamptz,
  reviewed_by text,
  reviewed_at timestamptz,
  review_note text,
  executed_by text,
  executed_at timestamptz,
  cancel_amount integer,
  currency text not null default 'KRW',
  toss_payment_key_snapshot text,
  toss_cancel_transaction_key text,
  gateway_response jsonb,
  error_code text,
  error_message text,
  retry_count integer not null default 0,
  next_retry_at timestamptz,
  notify_user_sent_at timestamptz,
  constraint billing_refund_requests_status_check
    check (
      status in (
        'PENDING',
        'REQUESTED',
        'UNDER_REVIEW',
        'APPROVED',
        'REJECTED',
        'EXECUTING',
        'REFUNDED',
        'FAILED_RETRYABLE',
        'FAILED_FINAL',
        'WITHDRAWN'
      )
    ),
  constraint billing_refund_requests_retry_count_nonnegative
    check (retry_count >= 0)
);

-- 7) Billing refund events
create table public.billing_refund_events (
  id bigint generated by default as identity primary key,
  request_id bigint not null references public.billing_refund_requests(id) on delete cascade,
  user_id text not null references public.rnest_users(user_id) on delete cascade,
  order_id text not null references public.billing_orders(order_id) on delete cascade,
  actor_user_id text,
  actor_role text not null default 'system',
  event_type text not null,
  from_status text,
  to_status text,
  message text,
  metadata jsonb,
  created_at timestamptz not null default now(),
  constraint billing_refund_events_actor_role_check
    check (actor_role in ('user', 'admin', 'system'))
);

-- 8) Med-safety credit usage ledger (real-time troubleshooting/ops)
create table public.med_safety_usage_events (
  id bigint generated by default as identity primary key,
  user_id text not null references public.rnest_users(user_id) on delete cascade,
  source text not null,
  delta integer not null,
  reason text not null,
  metadata jsonb,
  created_at timestamptz not null default now(),
  constraint med_safety_usage_events_source_check
    check (source in ('daily', 'extra', 'restore_daily', 'restore_extra')),
  constraint med_safety_usage_events_delta_nonzero_check
    check (delta <> 0)
);

-- 9) Shared updated_at trigger
create function public.tg_set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

create trigger trg_set_updated_at_rnest_users
before update on public.rnest_users
for each row execute function public.tg_set_updated_at();

create trigger trg_set_updated_at_rnest_user_state
before update on public.rnest_user_state
for each row execute function public.tg_set_updated_at();

create trigger trg_set_updated_at_ai_content
before update on public.ai_content
for each row execute function public.tg_set_updated_at();

create trigger trg_set_updated_at_billing_orders
before update on public.billing_orders
for each row execute function public.tg_set_updated_at();

create trigger trg_set_updated_at_refund_requests
before update on public.billing_refund_requests
for each row execute function public.tg_set_updated_at();

-- 10) User-state revision trigger
create function public.tg_log_rnest_user_state_revision()
returns trigger
language plpgsql
as $$
begin
  insert into public.rnest_user_state_revisions (user_id, payload, source)
  values (new.user_id, new.payload, 'api');
  return new;
end;
$$;

create trigger trg_log_rnest_user_state_revision
after insert or update on public.rnest_user_state
for each row execute function public.tg_log_rnest_user_state_revision();

-- 11) Indexes
create index idx_rnest_users_last_seen on public.rnest_users (last_seen desc);
create index idx_rnest_users_subscription on public.rnest_users (subscription_tier, subscription_status);
create index idx_rnest_users_usage_date on public.rnest_users (med_safety_usage_date);

create index idx_rnest_user_state_updated on public.rnest_user_state (updated_at desc);
create index idx_rnest_user_state_revisions_user_created on public.rnest_user_state_revisions (user_id, created_at desc);

create index idx_ai_content_date_iso on public.ai_content (date_iso);
create index idx_ai_content_updated on public.ai_content (updated_at desc);

create index idx_billing_orders_user_created on public.billing_orders (user_id, created_at desc);
create index idx_billing_orders_status on public.billing_orders (status);
create index idx_billing_orders_user_order_kind_created on public.billing_orders (user_id, order_kind, created_at desc);

create index idx_billing_refund_requests_user_requested on public.billing_refund_requests (user_id, requested_at desc);
create index idx_billing_refund_requests_order_status on public.billing_refund_requests (order_id, status);
create unique index ux_billing_refund_requests_open_order
  on public.billing_refund_requests (user_id, order_id)
  where status in ('PENDING', 'REQUESTED', 'UNDER_REVIEW', 'APPROVED', 'EXECUTING', 'FAILED_RETRYABLE');

create index idx_billing_refund_events_request_created on public.billing_refund_events (request_id, created_at desc);
create index idx_billing_refund_events_user_created on public.billing_refund_events (user_id, created_at desc);

create index idx_med_safety_usage_events_user_created on public.med_safety_usage_events (user_id, created_at desc);

-- 12) RLS + policies
alter table public.rnest_users enable row level security;
alter table public.rnest_user_state enable row level security;
alter table public.rnest_user_state_revisions enable row level security;
alter table public.ai_content enable row level security;
alter table public.billing_orders enable row level security;
alter table public.billing_refund_requests enable row level security;
alter table public.billing_refund_events enable row level security;
alter table public.med_safety_usage_events enable row level security;

drop policy if exists "rnest_users_select_own" on public.rnest_users;
drop policy if exists "rnest_users_insert_own" on public.rnest_users;
drop policy if exists "rnest_users_update_own" on public.rnest_users;
drop policy if exists "rnest_users_delete_own" on public.rnest_users;
create policy "rnest_users_select_own" on public.rnest_users for select to authenticated using ((select auth.uid())::text = user_id);
create policy "rnest_users_insert_own" on public.rnest_users for insert to authenticated with check ((select auth.uid())::text = user_id);
create policy "rnest_users_update_own" on public.rnest_users for update to authenticated using ((select auth.uid())::text = user_id) with check ((select auth.uid())::text = user_id);
create policy "rnest_users_delete_own" on public.rnest_users for delete to authenticated using ((select auth.uid())::text = user_id);

drop policy if exists "rnest_user_state_select_own" on public.rnest_user_state;
drop policy if exists "rnest_user_state_insert_own" on public.rnest_user_state;
drop policy if exists "rnest_user_state_update_own" on public.rnest_user_state;
drop policy if exists "rnest_user_state_delete_own" on public.rnest_user_state;
create policy "rnest_user_state_select_own" on public.rnest_user_state for select to authenticated using ((select auth.uid())::text = user_id);
create policy "rnest_user_state_insert_own" on public.rnest_user_state for insert to authenticated with check ((select auth.uid())::text = user_id);
create policy "rnest_user_state_update_own" on public.rnest_user_state for update to authenticated using ((select auth.uid())::text = user_id) with check ((select auth.uid())::text = user_id);
create policy "rnest_user_state_delete_own" on public.rnest_user_state for delete to authenticated using ((select auth.uid())::text = user_id);

drop policy if exists "rnest_user_state_revisions_select_own" on public.rnest_user_state_revisions;
create policy "rnest_user_state_revisions_select_own"
  on public.rnest_user_state_revisions
  for select to authenticated
  using ((select auth.uid())::text = user_id);

drop policy if exists "ai_content_select_own" on public.ai_content;
drop policy if exists "ai_content_insert_own" on public.ai_content;
drop policy if exists "ai_content_update_own" on public.ai_content;
drop policy if exists "ai_content_delete_own" on public.ai_content;
create policy "ai_content_select_own" on public.ai_content for select to authenticated using ((select auth.uid())::text = user_id);
create policy "ai_content_insert_own" on public.ai_content for insert to authenticated with check ((select auth.uid())::text = user_id);
create policy "ai_content_update_own" on public.ai_content for update to authenticated using ((select auth.uid())::text = user_id) with check ((select auth.uid())::text = user_id);
create policy "ai_content_delete_own" on public.ai_content for delete to authenticated using ((select auth.uid())::text = user_id);

drop policy if exists "billing_orders_select_own" on public.billing_orders;
create policy "billing_orders_select_own"
  on public.billing_orders
  for select to authenticated
  using ((select auth.uid())::text = user_id);

drop policy if exists "billing_refund_requests_select_own" on public.billing_refund_requests;
drop policy if exists "billing_refund_requests_insert_own" on public.billing_refund_requests;
drop policy if exists "billing_refund_requests_update_own" on public.billing_refund_requests;
create policy "billing_refund_requests_select_own"
  on public.billing_refund_requests
  for select to authenticated
  using ((select auth.uid())::text = user_id);
create policy "billing_refund_requests_insert_own"
  on public.billing_refund_requests
  for insert to authenticated
  with check ((select auth.uid())::text = user_id);
create policy "billing_refund_requests_update_own"
  on public.billing_refund_requests
  for update to authenticated
  using ((select auth.uid())::text = user_id)
  with check ((select auth.uid())::text = user_id);

drop policy if exists "billing_refund_events_select_own" on public.billing_refund_events;
create policy "billing_refund_events_select_own"
  on public.billing_refund_events
  for select to authenticated
  using ((select auth.uid())::text = user_id);

drop policy if exists "med_safety_usage_events_select_own" on public.med_safety_usage_events;
create policy "med_safety_usage_events_select_own"
  on public.med_safety_usage_events
  for select to authenticated
  using ((select auth.uid())::text = user_id);

-- 13) Admin-friendly views (one-screen overview)
create view public.v_user_data_overview as
select
  u.user_id,
  u.created_at,
  u.updated_at as user_updated_at,
  u.last_seen,
  u.subscription_tier,
  u.subscription_status,
  u.subscription_current_period_end,
  u.med_safety_extra_credits,
  u.med_safety_daily_used,
  u.med_safety_usage_date,
  s.updated_at as state_updated_at,
  CASE
    WHEN jsonb_typeof(s.payload -> 'schedule') = 'object'
      THEN (SELECT count(*)::integer FROM jsonb_object_keys(s.payload -> 'schedule') AS _k)
    ELSE 0
  END as schedule_days,
  CASE
    WHEN jsonb_typeof(s.payload -> 'notes') = 'object'
      THEN (SELECT count(*)::integer FROM jsonb_object_keys(s.payload -> 'notes') AS _k)
    ELSE 0
  END as note_days,
  CASE
    WHEN jsonb_typeof(s.payload -> 'emotions') = 'object'
      THEN (SELECT count(*)::integer FROM jsonb_object_keys(s.payload -> 'emotions') AS _k)
    ELSE 0
  END as emotion_days,
  CASE
    WHEN jsonb_typeof(s.payload -> 'bio') = 'object'
      THEN (SELECT count(*)::integer FROM jsonb_object_keys(s.payload -> 'bio') AS _k)
    ELSE 0
  END as bio_days,
  a.updated_at as ai_updated_at,
  a.date_iso as ai_date_iso
from public.rnest_users u
left join public.rnest_user_state s on s.user_id = u.user_id
left join public.ai_content a on a.user_id = u.user_id;

create view public.v_user_billing_summary as
select
  u.user_id,
  coalesce(sum(case when o.status = 'DONE' then o.amount else 0 end), 0)::bigint as paid_amount_total,
  coalesce(sum(case when o.status = 'DONE' and o.order_kind = 'credit_pack' then o.credit_pack_units else 0 end), 0)::bigint as credit_units_bought_total,
  coalesce(sum(case when o.status = 'DONE' and o.order_kind = 'subscription' then 1 else 0 end), 0)::bigint as subscription_paid_count,
  max(o.created_at) as latest_order_at
from public.rnest_users u
left join public.billing_orders o on o.user_id = u.user_id
group by u.user_id;

create view public.v_user_credit_live as
with credit_base as (
  select
    u.user_id,
    u.subscription_tier,
    u.subscription_status,
    u.subscription_current_period_end,
    greatest(0, u.med_safety_extra_credits) as extra_credits,
    greatest(0, u.med_safety_daily_used) as daily_used_raw,
    u.med_safety_usage_date,
    (now() at time zone 'Asia/Seoul')::date as kst_today
  from public.rnest_users u
)
select
  b.user_id,
  (
    b.subscription_tier = 'pro'
    and b.subscription_status = 'active'
    and (b.subscription_current_period_end is null or b.subscription_current_period_end > now())
  ) as is_pro_active,
  case
    when (
      b.subscription_tier = 'pro'
      and b.subscription_status = 'active'
      and (b.subscription_current_period_end is null or b.subscription_current_period_end > now())
    ) then 10
    else 0
  end as daily_limit,
  case
    when b.med_safety_usage_date = b.kst_today then b.daily_used_raw
    else 0
  end as daily_used,
  case
    when (
      b.subscription_tier = 'pro'
      and b.subscription_status = 'active'
      and (b.subscription_current_period_end is null or b.subscription_current_period_end > now())
    ) then greatest(
      0,
      10 - case when b.med_safety_usage_date = b.kst_today then b.daily_used_raw else 0 end
    )
    else 0
  end as daily_remaining,
  b.extra_credits,
  (
    case
      when (
        b.subscription_tier = 'pro'
        and b.subscription_status = 'active'
        and (b.subscription_current_period_end is null or b.subscription_current_period_end > now())
      ) then greatest(
        0,
        10 - case when b.med_safety_usage_date = b.kst_today then b.daily_used_raw else 0 end
      )
      else 0
    end
    + b.extra_credits
  ) as total_remaining,
  b.med_safety_usage_date,
  b.kst_today as kst_today
from credit_base b;

comment on table public.rnest_users is '사용자 기본 상태/구독/크레딧 요약';
comment on table public.rnest_user_state is '사용자 기록 스냅샷(캘린더/노트/감정/바이오)';
comment on table public.rnest_user_state_revisions is '사용자 상태 변경 이력(복구/감사)';
comment on table public.ai_content is 'AI 분석 결과 캐시';
comment on table public.billing_orders is '결제 주문 원장';
comment on table public.billing_refund_requests is '환불 요청 상태';
comment on table public.billing_refund_events is '환불 상태 전이 이벤트';
comment on table public.med_safety_usage_events is 'AI 검색 크레딧 차감/복원 이력';
comment on view public.v_user_data_overview is '유저별 상태 저장 현황 요약 뷰';
comment on view public.v_user_billing_summary is '유저별 누적 결제/크레딧 구매 요약 뷰';
comment on view public.v_user_credit_live is '유저별 실시간 크레딧 잔여량 계산 뷰(KST 기준)';

select pg_notify('pgrst', 'reload schema');

commit;
