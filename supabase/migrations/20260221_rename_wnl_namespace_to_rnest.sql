-- Rename namespace from wnl_* to rnest_* without data loss.
-- Safe to run multiple times.

begin;

-- 1) Rename base tables
DO $$
BEGIN
  IF to_regclass('public.rnest_users') IS NULL AND to_regclass('public.wnl_users') IS NOT NULL THEN
    ALTER TABLE public.wnl_users RENAME TO rnest_users;
  END IF;

  IF to_regclass('public.rnest_user_state') IS NULL AND to_regclass('public.wnl_user_state') IS NOT NULL THEN
    ALTER TABLE public.wnl_user_state RENAME TO rnest_user_state;
  END IF;

  IF to_regclass('public.rnest_user_state_revisions') IS NULL AND to_regclass('public.wnl_user_state_revisions') IS NOT NULL THEN
    ALTER TABLE public.wnl_user_state_revisions RENAME TO rnest_user_state_revisions;
  END IF;

  IF to_regclass('public.rnest_daily_logs') IS NULL AND to_regclass('public.wnl_daily_logs') IS NOT NULL THEN
    ALTER TABLE public.wnl_daily_logs RENAME TO rnest_daily_logs;
  END IF;
END
$$;

-- 2) Ensure required tables/columns exist
ALTER TABLE IF EXISTS public.rnest_users
  ADD COLUMN IF NOT EXISTS updated_at timestamptz NOT NULL DEFAULT now();

ALTER TABLE IF EXISTS public.rnest_users
  ADD COLUMN IF NOT EXISTS med_safety_extra_credits integer NOT NULL DEFAULT 0,
  ADD COLUMN IF NOT EXISTS med_safety_daily_used integer NOT NULL DEFAULT 0,
  ADD COLUMN IF NOT EXISTS med_safety_usage_date date;

-- normalize potentially dirty values
DO $$
BEGIN
  IF to_regclass('public.rnest_users') IS NOT NULL THEN
    UPDATE public.rnest_users
    SET
      updated_at = COALESCE(updated_at, now()),
      med_safety_extra_credits = GREATEST(0, COALESCE(med_safety_extra_credits, 0)),
      med_safety_daily_used = GREATEST(0, COALESCE(med_safety_daily_used, 0))
    WHERE
      updated_at IS NULL
      OR med_safety_extra_credits IS NULL
      OR med_safety_extra_credits < 0
      OR med_safety_daily_used IS NULL
      OR med_safety_daily_used < 0;
  END IF;
END
$$;

DO $$
BEGIN
  IF to_regclass('public.rnest_users') IS NULL THEN
    RAISE EXCEPTION 'rnest_users table is required before running this migration';
  END IF;
END
$$;

CREATE TABLE IF NOT EXISTS public.rnest_user_state (
  user_id text PRIMARY KEY REFERENCES public.rnest_users(user_id) ON DELETE CASCADE,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT rnest_user_state_payload_object_check
    CHECK (jsonb_typeof(payload) = 'object')
);

CREATE TABLE IF NOT EXISTS public.rnest_user_state_revisions (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id text NOT NULL REFERENCES public.rnest_users(user_id) ON DELETE CASCADE,
  payload jsonb NOT NULL,
  source text NOT NULL DEFAULT 'api',
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT rnest_user_state_revisions_payload_object_check
    CHECK (jsonb_typeof(payload) = 'object')
);

-- 3) Rename old constraints if they still exist
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'wnl_users_subscription_tier_check'
      AND conrelid = 'public.rnest_users'::regclass
  ) AND NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'rnest_users_subscription_tier_check'
      AND conrelid = 'public.rnest_users'::regclass
  ) THEN
    ALTER TABLE public.rnest_users RENAME CONSTRAINT wnl_users_subscription_tier_check TO rnest_users_subscription_tier_check;
  END IF;

  IF EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'wnl_users_subscription_status_check'
      AND conrelid = 'public.rnest_users'::regclass
  ) AND NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'rnest_users_subscription_status_check'
      AND conrelid = 'public.rnest_users'::regclass
  ) THEN
    ALTER TABLE public.rnest_users RENAME CONSTRAINT wnl_users_subscription_status_check TO rnest_users_subscription_status_check;
  END IF;

  IF EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'wnl_users_med_safety_extra_credits_nonnegative'
      AND conrelid = 'public.rnest_users'::regclass
  ) AND NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'rnest_users_med_safety_extra_credits_nonnegative'
      AND conrelid = 'public.rnest_users'::regclass
  ) THEN
    ALTER TABLE public.rnest_users RENAME CONSTRAINT wnl_users_med_safety_extra_credits_nonnegative TO rnest_users_med_safety_extra_credits_nonnegative;
  END IF;

  IF EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'wnl_users_med_safety_daily_used_nonnegative'
      AND conrelid = 'public.rnest_users'::regclass
  ) AND NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'rnest_users_med_safety_daily_used_nonnegative'
      AND conrelid = 'public.rnest_users'::regclass
  ) THEN
    ALTER TABLE public.rnest_users RENAME CONSTRAINT wnl_users_med_safety_daily_used_nonnegative TO rnest_users_med_safety_daily_used_nonnegative;
  END IF;

  IF EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'wnl_user_state_payload_object_check'
      AND conrelid = 'public.rnest_user_state'::regclass
  ) AND NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'rnest_user_state_payload_object_check'
      AND conrelid = 'public.rnest_user_state'::regclass
  ) THEN
    ALTER TABLE public.rnest_user_state RENAME CONSTRAINT wnl_user_state_payload_object_check TO rnest_user_state_payload_object_check;
  END IF;

  IF EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'wnl_user_state_revisions_payload_object_check'
      AND conrelid = 'public.rnest_user_state_revisions'::regclass
  ) AND NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'rnest_user_state_revisions_payload_object_check'
      AND conrelid = 'public.rnest_user_state_revisions'::regclass
  ) THEN
    ALTER TABLE public.rnest_user_state_revisions RENAME CONSTRAINT wnl_user_state_revisions_payload_object_check TO rnest_user_state_revisions_payload_object_check;
  END IF;
END
$$;

-- 4) Re-apply non-negative constraints deterministically
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'rnest_users_med_safety_extra_credits_nonnegative' AND conrelid = 'public.rnest_users'::regclass) THEN
    ALTER TABLE public.rnest_users DROP CONSTRAINT rnest_users_med_safety_extra_credits_nonnegative;
  END IF;
  ALTER TABLE public.rnest_users
    ADD CONSTRAINT rnest_users_med_safety_extra_credits_nonnegative
    CHECK (med_safety_extra_credits >= 0);

  IF EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'rnest_users_med_safety_daily_used_nonnegative' AND conrelid = 'public.rnest_users'::regclass) THEN
    ALTER TABLE public.rnest_users DROP CONSTRAINT rnest_users_med_safety_daily_used_nonnegative;
  END IF;
  ALTER TABLE public.rnest_users
    ADD CONSTRAINT rnest_users_med_safety_daily_used_nonnegative
    CHECK (med_safety_daily_used >= 0);
END
$$;

-- 5) Trigger functions and triggers
DO $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM pg_proc p
    JOIN pg_namespace n ON n.oid = p.pronamespace
    WHERE n.nspname = 'public'
      AND p.proname = 'tg_log_wnl_user_state_revision'
  ) THEN
    ALTER FUNCTION public.tg_log_wnl_user_state_revision() RENAME TO tg_log_rnest_user_state_revision;
  END IF;
END
$$;

CREATE OR REPLACE FUNCTION public.tg_set_updated_at()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION public.tg_log_rnest_user_state_revision()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  IF TG_OP = 'UPDATE' AND NEW.payload IS NOT DISTINCT FROM OLD.payload THEN
    RETURN NEW;
  END IF;

  INSERT INTO public.rnest_user_state_revisions (user_id, payload, source)
  VALUES (NEW.user_id, NEW.payload, 'api');
  RETURN NEW;
END;
$$;

DO $$
BEGIN
  DROP TRIGGER IF EXISTS trg_set_updated_at_wnl_users ON public.rnest_users;
  DROP TRIGGER IF EXISTS trg_set_updated_at_rnest_users ON public.rnest_users;
  CREATE TRIGGER trg_set_updated_at_rnest_users
    BEFORE UPDATE ON public.rnest_users
    FOR EACH ROW EXECUTE FUNCTION public.tg_set_updated_at();

  DROP TRIGGER IF EXISTS trg_set_updated_at_wnl_user_state ON public.rnest_user_state;
  DROP TRIGGER IF EXISTS trg_set_updated_at_rnest_user_state ON public.rnest_user_state;
  CREATE TRIGGER trg_set_updated_at_rnest_user_state
    BEFORE UPDATE ON public.rnest_user_state
    FOR EACH ROW EXECUTE FUNCTION public.tg_set_updated_at();

  DROP TRIGGER IF EXISTS trg_log_wnl_user_state_revision ON public.rnest_user_state;
  DROP TRIGGER IF EXISTS trg_log_rnest_user_state_revision ON public.rnest_user_state;
  CREATE TRIGGER trg_log_rnest_user_state_revision
    AFTER INSERT OR UPDATE ON public.rnest_user_state
    FOR EACH ROW EXECUTE FUNCTION public.tg_log_rnest_user_state_revision();
END
$$;

-- 6) Index rename + ensure
DO $$
BEGIN
  IF to_regclass('public.idx_wnl_users_last_seen') IS NOT NULL
    AND to_regclass('public.idx_rnest_users_last_seen') IS NULL THEN
    ALTER INDEX public.idx_wnl_users_last_seen RENAME TO idx_rnest_users_last_seen;
  END IF;

  IF to_regclass('public.idx_wnl_users_subscription') IS NOT NULL
    AND to_regclass('public.idx_rnest_users_subscription') IS NULL THEN
    ALTER INDEX public.idx_wnl_users_subscription RENAME TO idx_rnest_users_subscription;
  END IF;

  IF to_regclass('public.idx_wnl_users_usage_date') IS NOT NULL
    AND to_regclass('public.idx_rnest_users_usage_date') IS NULL THEN
    ALTER INDEX public.idx_wnl_users_usage_date RENAME TO idx_rnest_users_usage_date;
  END IF;

  IF to_regclass('public.idx_wnl_user_state_updated') IS NOT NULL
    AND to_regclass('public.idx_rnest_user_state_updated') IS NULL THEN
    ALTER INDEX public.idx_wnl_user_state_updated RENAME TO idx_rnest_user_state_updated;
  END IF;

  IF to_regclass('public.idx_wnl_user_state_revisions_user_created') IS NOT NULL
    AND to_regclass('public.idx_rnest_user_state_revisions_user_created') IS NULL THEN
    ALTER INDEX public.idx_wnl_user_state_revisions_user_created RENAME TO idx_rnest_user_state_revisions_user_created;
  END IF;
END
$$;

CREATE INDEX IF NOT EXISTS idx_rnest_users_last_seen ON public.rnest_users (last_seen DESC);
CREATE INDEX IF NOT EXISTS idx_rnest_users_subscription ON public.rnest_users (subscription_tier, subscription_status);
CREATE INDEX IF NOT EXISTS idx_rnest_users_usage_date ON public.rnest_users (med_safety_usage_date);
CREATE INDEX IF NOT EXISTS idx_rnest_user_state_updated ON public.rnest_user_state (updated_at DESC);
CREATE INDEX IF NOT EXISTS idx_rnest_user_state_revisions_user_created ON public.rnest_user_state_revisions (user_id, created_at DESC);

-- 7) RLS + policies
ALTER TABLE public.rnest_users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.rnest_user_state ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.rnest_user_state_revisions ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "wnl_users_select_own" ON public.rnest_users;
DROP POLICY IF EXISTS "wnl_users_insert_own" ON public.rnest_users;
DROP POLICY IF EXISTS "wnl_users_update_own" ON public.rnest_users;
DROP POLICY IF EXISTS "wnl_users_delete_own" ON public.rnest_users;
DROP POLICY IF EXISTS "rnest_users_select_own" ON public.rnest_users;
DROP POLICY IF EXISTS "rnest_users_insert_own" ON public.rnest_users;
DROP POLICY IF EXISTS "rnest_users_update_own" ON public.rnest_users;
DROP POLICY IF EXISTS "rnest_users_delete_own" ON public.rnest_users;

CREATE POLICY "rnest_users_select_own"
  ON public.rnest_users FOR SELECT TO authenticated
  USING ((SELECT auth.uid())::text = user_id);

CREATE POLICY "rnest_users_insert_own"
  ON public.rnest_users FOR INSERT TO authenticated
  WITH CHECK ((SELECT auth.uid())::text = user_id);

CREATE POLICY "rnest_users_update_own"
  ON public.rnest_users FOR UPDATE TO authenticated
  USING ((SELECT auth.uid())::text = user_id)
  WITH CHECK ((SELECT auth.uid())::text = user_id);

CREATE POLICY "rnest_users_delete_own"
  ON public.rnest_users FOR DELETE TO authenticated
  USING ((SELECT auth.uid())::text = user_id);

DROP POLICY IF EXISTS "wnl_user_state_select_own" ON public.rnest_user_state;
DROP POLICY IF EXISTS "wnl_user_state_insert_own" ON public.rnest_user_state;
DROP POLICY IF EXISTS "wnl_user_state_update_own" ON public.rnest_user_state;
DROP POLICY IF EXISTS "wnl_user_state_delete_own" ON public.rnest_user_state;
DROP POLICY IF EXISTS "rnest_user_state_select_own" ON public.rnest_user_state;
DROP POLICY IF EXISTS "rnest_user_state_insert_own" ON public.rnest_user_state;
DROP POLICY IF EXISTS "rnest_user_state_update_own" ON public.rnest_user_state;
DROP POLICY IF EXISTS "rnest_user_state_delete_own" ON public.rnest_user_state;

CREATE POLICY "rnest_user_state_select_own"
  ON public.rnest_user_state FOR SELECT TO authenticated
  USING ((SELECT auth.uid())::text = user_id);

CREATE POLICY "rnest_user_state_insert_own"
  ON public.rnest_user_state FOR INSERT TO authenticated
  WITH CHECK ((SELECT auth.uid())::text = user_id);

CREATE POLICY "rnest_user_state_update_own"
  ON public.rnest_user_state FOR UPDATE TO authenticated
  USING ((SELECT auth.uid())::text = user_id)
  WITH CHECK ((SELECT auth.uid())::text = user_id);

CREATE POLICY "rnest_user_state_delete_own"
  ON public.rnest_user_state FOR DELETE TO authenticated
  USING ((SELECT auth.uid())::text = user_id);

DROP POLICY IF EXISTS "wnl_user_state_revisions_select_own" ON public.rnest_user_state_revisions;
DROP POLICY IF EXISTS "rnest_user_state_revisions_select_own" ON public.rnest_user_state_revisions;

CREATE POLICY "rnest_user_state_revisions_select_own"
  ON public.rnest_user_state_revisions
  FOR SELECT TO authenticated
  USING ((SELECT auth.uid())::text = user_id);

-- 8) Admin operational views (for quick per-user inspection)
CREATE OR REPLACE VIEW public.v_user_data_overview AS
SELECT
  u.user_id,
  u.created_at,
  u.updated_at AS user_updated_at,
  u.last_seen,
  u.subscription_tier,
  u.subscription_status,
  u.subscription_current_period_end,
  u.med_safety_extra_credits,
  u.med_safety_daily_used,
  u.med_safety_usage_date,
  s.updated_at AS state_updated_at,
  CASE
    WHEN jsonb_typeof(s.payload -> 'schedule') = 'object'
      THEN (SELECT count(*)::integer FROM jsonb_object_keys(s.payload -> 'schedule') AS _k)
    ELSE 0
  END AS schedule_days,
  CASE
    WHEN jsonb_typeof(s.payload -> 'notes') = 'object'
      THEN (SELECT count(*)::integer FROM jsonb_object_keys(s.payload -> 'notes') AS _k)
    ELSE 0
  END AS note_days,
  CASE
    WHEN jsonb_typeof(s.payload -> 'emotions') = 'object'
      THEN (SELECT count(*)::integer FROM jsonb_object_keys(s.payload -> 'emotions') AS _k)
    ELSE 0
  END AS emotion_days,
  CASE
    WHEN jsonb_typeof(s.payload -> 'bio') = 'object'
      THEN (SELECT count(*)::integer FROM jsonb_object_keys(s.payload -> 'bio') AS _k)
    ELSE 0
  END AS bio_days,
  a.updated_at AS ai_updated_at,
  a.date_iso AS ai_date_iso
FROM public.rnest_users u
LEFT JOIN public.rnest_user_state s ON s.user_id = u.user_id
LEFT JOIN public.ai_content a ON a.user_id = u.user_id;

CREATE OR REPLACE VIEW public.v_user_billing_summary AS
SELECT
  u.user_id,
  coalesce(sum(case when o.status = 'DONE' then o.amount else 0 end), 0)::bigint AS paid_amount_total,
  coalesce(sum(case when o.status = 'DONE' and o.order_kind = 'credit_pack' then o.credit_pack_units else 0 end), 0)::bigint AS credit_units_bought_total,
  coalesce(sum(case when o.status = 'DONE' and o.order_kind = 'subscription' then 1 else 0 end), 0)::bigint AS subscription_paid_count,
  max(o.created_at) AS latest_order_at
FROM public.rnest_users u
LEFT JOIN public.billing_orders o ON o.user_id = u.user_id
GROUP BY u.user_id;

CREATE OR REPLACE VIEW public.v_user_credit_live AS
WITH credit_base AS (
  SELECT
    u.user_id,
    u.subscription_tier,
    u.subscription_status,
    u.subscription_current_period_end,
    greatest(0, u.med_safety_extra_credits) AS extra_credits,
    greatest(0, u.med_safety_daily_used) AS daily_used_raw,
    u.med_safety_usage_date,
    (now() AT TIME ZONE 'Asia/Seoul')::date AS kst_today
  FROM public.rnest_users u
)
SELECT
  b.user_id,
  (
    b.subscription_tier = 'pro'
    AND b.subscription_status = 'active'
    AND (b.subscription_current_period_end IS NULL OR b.subscription_current_period_end > now())
  ) AS is_pro_active,
  CASE
    WHEN (
      b.subscription_tier = 'pro'
      AND b.subscription_status = 'active'
      AND (b.subscription_current_period_end IS NULL OR b.subscription_current_period_end > now())
    ) THEN 10
    ELSE 0
  END AS daily_limit,
  CASE
    WHEN b.med_safety_usage_date = b.kst_today THEN b.daily_used_raw
    ELSE 0
  END AS daily_used,
  CASE
    WHEN (
      b.subscription_tier = 'pro'
      AND b.subscription_status = 'active'
      AND (b.subscription_current_period_end IS NULL OR b.subscription_current_period_end > now())
    ) THEN greatest(
      0,
      10 - CASE WHEN b.med_safety_usage_date = b.kst_today THEN b.daily_used_raw ELSE 0 END
    )
    ELSE 0
  END AS daily_remaining,
  b.extra_credits,
  (
    CASE
      WHEN (
        b.subscription_tier = 'pro'
        AND b.subscription_status = 'active'
        AND (b.subscription_current_period_end IS NULL OR b.subscription_current_period_end > now())
      ) THEN greatest(
        0,
        10 - CASE WHEN b.med_safety_usage_date = b.kst_today THEN b.daily_used_raw ELSE 0 END
      )
      ELSE 0
    END
    + b.extra_credits
  ) AS total_remaining,
  b.med_safety_usage_date,
  b.kst_today AS kst_today
FROM credit_base b;

COMMENT ON TABLE public.rnest_users IS '사용자 기본 상태/구독/크레딧 요약';
COMMENT ON TABLE public.rnest_user_state IS '사용자 기록 스냅샷(캘린더/노트/감정/바이오)';
COMMENT ON TABLE public.rnest_user_state_revisions IS '사용자 상태 변경 이력(복구/감사)';

SELECT pg_notify('pgrst', 'reload schema');

commit;
