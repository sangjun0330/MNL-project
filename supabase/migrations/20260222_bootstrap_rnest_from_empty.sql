-- RNest fresh bootstrap migration (for completely empty DB)
-- This script is safe to run on an empty database and can also reset existing RNest app tables.

begin;

-- 0) Cleanup: views/functions/tables
-- Views
DROP VIEW IF EXISTS public.v_user_credit_live;
DROP VIEW IF EXISTS public.v_user_billing_summary;
DROP VIEW IF EXISTS public.v_user_data_overview;

-- Tables
DROP TABLE IF EXISTS public.med_safety_usage_events CASCADE;
DROP TABLE IF EXISTS public.billing_refund_events CASCADE;
DROP TABLE IF EXISTS public.billing_refund_requests CASCADE;
DROP TABLE IF EXISTS public.billing_orders CASCADE;
DROP TABLE IF EXISTS public.ai_content CASCADE;
DROP TABLE IF EXISTS public.rnest_user_state_revisions CASCADE;
DROP TABLE IF EXISTS public.rnest_user_state CASCADE;
DROP TABLE IF EXISTS public.rnest_users CASCADE;

-- Functions (drop after tables to avoid dependency errors)
DROP FUNCTION IF EXISTS public.tg_log_rnest_user_state_revision();
DROP FUNCTION IF EXISTS public.tg_set_updated_at();

-- 1) Users (source of truth for subscription + med safety credits)
CREATE TABLE public.rnest_users (
  user_id text PRIMARY KEY,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  last_seen timestamptz NOT NULL DEFAULT now(),

  subscription_tier text NOT NULL DEFAULT 'free',
  subscription_status text NOT NULL DEFAULT 'inactive',
  subscription_started_at timestamptz,
  subscription_current_period_end timestamptz,
  subscription_updated_at timestamptz,

  subscription_cancel_at_period_end boolean NOT NULL DEFAULT false,
  subscription_cancel_scheduled_at timestamptz,
  subscription_canceled_at timestamptz,
  subscription_cancel_reason text,

  toss_customer_key text,
  toss_last_order_id text,

  med_safety_extra_credits integer NOT NULL DEFAULT 0,
  med_safety_daily_used integer NOT NULL DEFAULT 0,
  med_safety_usage_date date,

  CONSTRAINT rnest_users_subscription_tier_check
    CHECK (subscription_tier IN ('free', 'pro')),
  CONSTRAINT rnest_users_subscription_status_check
    CHECK (subscription_status IN ('inactive', 'active', 'expired')),
  CONSTRAINT rnest_users_med_safety_extra_credits_nonnegative
    CHECK (med_safety_extra_credits >= 0),
  CONSTRAINT rnest_users_med_safety_daily_used_nonnegative
    CHECK (med_safety_daily_used >= 0)
);

-- 2) User state snapshot (latest)
CREATE TABLE public.rnest_user_state (
  user_id text PRIMARY KEY REFERENCES public.rnest_users(user_id) ON DELETE CASCADE,
  payload jsonb NOT NULL DEFAULT '{}'::jsonb,
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT rnest_user_state_payload_object_check
    CHECK (jsonb_typeof(payload) = 'object')
);

-- 3) User state revisions (audit)
CREATE TABLE public.rnest_user_state_revisions (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id text NOT NULL REFERENCES public.rnest_users(user_id) ON DELETE CASCADE,
  payload jsonb NOT NULL,
  source text NOT NULL DEFAULT 'api',
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT rnest_user_state_revisions_payload_object_check
    CHECK (jsonb_typeof(payload) = 'object')
);

-- 4) AI content cache
CREATE TABLE public.ai_content (
  user_id text PRIMARY KEY REFERENCES public.rnest_users(user_id) ON DELETE CASCADE,
  date_iso text NOT NULL,
  language text NOT NULL DEFAULT 'ko',
  data jsonb NOT NULL DEFAULT '{}'::jsonb,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT ai_content_language_check
    CHECK (language IN ('ko', 'en')),
  CONSTRAINT ai_content_data_object_check
    CHECK (jsonb_typeof(data) = 'object')
);

-- 5) Billing orders (subscription + credit pack)
CREATE TABLE public.billing_orders (
  order_id text PRIMARY KEY,
  user_id text NOT NULL REFERENCES public.rnest_users(user_id) ON DELETE CASCADE,
  plan_tier text NOT NULL,
  order_kind text NOT NULL DEFAULT 'subscription',
  credit_pack_units integer NOT NULL DEFAULT 0,
  amount integer NOT NULL,
  currency text NOT NULL DEFAULT 'KRW',
  status text NOT NULL DEFAULT 'READY',
  order_name text NOT NULL,
  payment_key text,
  fail_code text,
  fail_message text,
  toss_response jsonb,
  approved_at timestamptz,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),

  CONSTRAINT billing_orders_amount_positive_check
    CHECK (amount > 0),
  CONSTRAINT billing_orders_status_check
    CHECK (status IN ('READY', 'DONE', 'FAILED', 'CANCELED')),
  CONSTRAINT billing_orders_plan_tier_check
    CHECK (plan_tier IN ('free', 'pro')),
  CONSTRAINT billing_orders_order_kind_check
    CHECK (order_kind IN ('subscription', 'credit_pack')),
  CONSTRAINT billing_orders_credit_pack_units_nonnegative
    CHECK (credit_pack_units >= 0),
  CONSTRAINT billing_orders_credit_pack_units_consistency_check
    CHECK (
      (order_kind = 'subscription' AND credit_pack_units = 0)
      OR
      (order_kind = 'credit_pack' AND credit_pack_units > 0)
    )
);

-- 6) Refund requests
CREATE TABLE public.billing_refund_requests (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id text NOT NULL REFERENCES public.rnest_users(user_id) ON DELETE CASCADE,
  order_id text NOT NULL REFERENCES public.billing_orders(order_id) ON DELETE CASCADE,
  reason text NOT NULL,
  status text NOT NULL DEFAULT 'REQUESTED',
  admin_note text,
  requested_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  notified_at timestamptz,

  reviewed_by text,
  reviewed_at timestamptz,
  review_note text,

  executed_by text,
  executed_at timestamptz,

  cancel_amount integer,
  currency text NOT NULL DEFAULT 'KRW',

  toss_payment_key_snapshot text,
  toss_cancel_transaction_key text,
  gateway_response jsonb,

  error_code text,
  error_message text,
  retry_count integer NOT NULL DEFAULT 0,
  next_retry_at timestamptz,
  notify_user_sent_at timestamptz,

  CONSTRAINT billing_refund_requests_status_check
    CHECK (
      status IN (
        'PENDING',
        'REQUESTED',
        'UNDER_REVIEW',
        'APPROVED',
        'REJECTED',
        'EXECUTING',
        'REFUNDED',
        'FAILED_RETRYABLE',
        'FAILED_FINAL',
        'WITHDRAWN'
      )
    ),
  CONSTRAINT billing_refund_requests_retry_count_nonnegative
    CHECK (retry_count >= 0),
  CONSTRAINT billing_refund_requests_cancel_amount_nonnegative
    CHECK (cancel_amount IS NULL OR cancel_amount >= 0)
);

-- 7) Refund events (state transition log)
CREATE TABLE public.billing_refund_events (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  request_id bigint NOT NULL REFERENCES public.billing_refund_requests(id) ON DELETE CASCADE,
  user_id text NOT NULL REFERENCES public.rnest_users(user_id) ON DELETE CASCADE,
  order_id text NOT NULL REFERENCES public.billing_orders(order_id) ON DELETE CASCADE,
  actor_user_id text,
  actor_role text NOT NULL DEFAULT 'system',
  event_type text NOT NULL,
  from_status text,
  to_status text,
  message text,
  metadata jsonb,
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT billing_refund_events_actor_role_check
    CHECK (actor_role IN ('user', 'admin', 'system'))
);

-- 8) Med safety usage ledger
CREATE TABLE public.med_safety_usage_events (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id text NOT NULL REFERENCES public.rnest_users(user_id) ON DELETE CASCADE,
  source text NOT NULL,
  delta integer NOT NULL,
  reason text NOT NULL,
  metadata jsonb,
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT med_safety_usage_events_source_check
    CHECK (source IN ('daily', 'extra', 'restore_daily', 'restore_extra')),
  CONSTRAINT med_safety_usage_events_delta_nonzero_check
    CHECK (delta <> 0)
);

-- 9) Generic updated_at trigger
CREATE FUNCTION public.tg_set_updated_at()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

CREATE TRIGGER trg_set_updated_at_rnest_users
BEFORE UPDATE ON public.rnest_users
FOR EACH ROW EXECUTE FUNCTION public.tg_set_updated_at();

CREATE TRIGGER trg_set_updated_at_rnest_user_state
BEFORE UPDATE ON public.rnest_user_state
FOR EACH ROW EXECUTE FUNCTION public.tg_set_updated_at();

CREATE TRIGGER trg_set_updated_at_ai_content
BEFORE UPDATE ON public.ai_content
FOR EACH ROW EXECUTE FUNCTION public.tg_set_updated_at();

CREATE TRIGGER trg_set_updated_at_billing_orders
BEFORE UPDATE ON public.billing_orders
FOR EACH ROW EXECUTE FUNCTION public.tg_set_updated_at();

CREATE TRIGGER trg_set_updated_at_refund_requests
BEFORE UPDATE ON public.billing_refund_requests
FOR EACH ROW EXECUTE FUNCTION public.tg_set_updated_at();

-- 10) Revision logging trigger
CREATE FUNCTION public.tg_log_rnest_user_state_revision()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  IF TG_OP = 'UPDATE' AND NEW.payload IS NOT DISTINCT FROM OLD.payload THEN
    RETURN NEW;
  END IF;

  INSERT INTO public.rnest_user_state_revisions (user_id, payload, source)
  VALUES (NEW.user_id, NEW.payload, 'api');
  RETURN NEW;
END;
$$;

CREATE TRIGGER trg_log_rnest_user_state_revision
AFTER INSERT OR UPDATE ON public.rnest_user_state
FOR EACH ROW EXECUTE FUNCTION public.tg_log_rnest_user_state_revision();

-- 11) Indexes
CREATE INDEX idx_rnest_users_last_seen ON public.rnest_users (last_seen DESC);
CREATE INDEX idx_rnest_users_subscription ON public.rnest_users (subscription_tier, subscription_status);
CREATE INDEX idx_rnest_users_usage_date ON public.rnest_users (med_safety_usage_date);

CREATE INDEX idx_rnest_user_state_updated ON public.rnest_user_state (updated_at DESC);
CREATE INDEX idx_rnest_user_state_revisions_user_created ON public.rnest_user_state_revisions (user_id, created_at DESC);

CREATE INDEX idx_ai_content_date_iso ON public.ai_content (date_iso);
CREATE INDEX idx_ai_content_updated ON public.ai_content (updated_at DESC);

CREATE INDEX idx_billing_orders_user_created ON public.billing_orders (user_id, created_at DESC);
CREATE INDEX idx_billing_orders_status ON public.billing_orders (status);
CREATE INDEX idx_billing_orders_user_order_kind_created ON public.billing_orders (user_id, order_kind, created_at DESC);
CREATE INDEX idx_billing_orders_admin_status_kind_created ON public.billing_orders (status, order_kind, created_at DESC);

CREATE INDEX idx_billing_refund_requests_user_requested ON public.billing_refund_requests (user_id, requested_at DESC);
CREATE INDEX idx_billing_refund_requests_order_status ON public.billing_refund_requests (order_id, status);
CREATE UNIQUE INDEX ux_billing_refund_requests_open_order
  ON public.billing_refund_requests (user_id, order_id)
  WHERE status IN ('PENDING', 'REQUESTED', 'UNDER_REVIEW', 'APPROVED', 'EXECUTING', 'FAILED_RETRYABLE');

CREATE INDEX idx_billing_refund_events_request_created ON public.billing_refund_events (request_id, created_at DESC);
CREATE INDEX idx_billing_refund_events_user_created ON public.billing_refund_events (user_id, created_at DESC);

CREATE INDEX idx_med_safety_usage_events_user_created ON public.med_safety_usage_events (user_id, created_at DESC);

-- 12) RLS
ALTER TABLE public.rnest_users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.rnest_user_state ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.rnest_user_state_revisions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ai_content ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.billing_orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.billing_refund_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.billing_refund_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.med_safety_usage_events ENABLE ROW LEVEL SECURITY;

-- Policies: rnest_users
DROP POLICY IF EXISTS "rnest_users_select_own" ON public.rnest_users;
DROP POLICY IF EXISTS "rnest_users_insert_own" ON public.rnest_users;
DROP POLICY IF EXISTS "rnest_users_update_own" ON public.rnest_users;
DROP POLICY IF EXISTS "rnest_users_delete_own" ON public.rnest_users;

CREATE POLICY "rnest_users_select_own"
  ON public.rnest_users FOR SELECT TO authenticated
  USING ((SELECT auth.uid())::text = user_id);

CREATE POLICY "rnest_users_insert_own"
  ON public.rnest_users FOR INSERT TO authenticated
  WITH CHECK ((SELECT auth.uid())::text = user_id);

CREATE POLICY "rnest_users_update_own"
  ON public.rnest_users FOR UPDATE TO authenticated
  USING ((SELECT auth.uid())::text = user_id)
  WITH CHECK ((SELECT auth.uid())::text = user_id);

CREATE POLICY "rnest_users_delete_own"
  ON public.rnest_users FOR DELETE TO authenticated
  USING ((SELECT auth.uid())::text = user_id);

-- Policies: rnest_user_state
DROP POLICY IF EXISTS "rnest_user_state_select_own" ON public.rnest_user_state;
DROP POLICY IF EXISTS "rnest_user_state_insert_own" ON public.rnest_user_state;
DROP POLICY IF EXISTS "rnest_user_state_update_own" ON public.rnest_user_state;
DROP POLICY IF EXISTS "rnest_user_state_delete_own" ON public.rnest_user_state;

CREATE POLICY "rnest_user_state_select_own"
  ON public.rnest_user_state FOR SELECT TO authenticated
  USING ((SELECT auth.uid())::text = user_id);

CREATE POLICY "rnest_user_state_insert_own"
  ON public.rnest_user_state FOR INSERT TO authenticated
  WITH CHECK ((SELECT auth.uid())::text = user_id);

CREATE POLICY "rnest_user_state_update_own"
  ON public.rnest_user_state FOR UPDATE TO authenticated
  USING ((SELECT auth.uid())::text = user_id)
  WITH CHECK ((SELECT auth.uid())::text = user_id);

CREATE POLICY "rnest_user_state_delete_own"
  ON public.rnest_user_state FOR DELETE TO authenticated
  USING ((SELECT auth.uid())::text = user_id);

-- Policies: rnest_user_state_revisions
DROP POLICY IF EXISTS "rnest_user_state_revisions_select_own" ON public.rnest_user_state_revisions;
CREATE POLICY "rnest_user_state_revisions_select_own"
  ON public.rnest_user_state_revisions FOR SELECT TO authenticated
  USING ((SELECT auth.uid())::text = user_id);

-- Policies: ai_content
DROP POLICY IF EXISTS "ai_content_select_own" ON public.ai_content;
DROP POLICY IF EXISTS "ai_content_insert_own" ON public.ai_content;
DROP POLICY IF EXISTS "ai_content_update_own" ON public.ai_content;
DROP POLICY IF EXISTS "ai_content_delete_own" ON public.ai_content;

CREATE POLICY "ai_content_select_own"
  ON public.ai_content FOR SELECT TO authenticated
  USING ((SELECT auth.uid())::text = user_id);

CREATE POLICY "ai_content_insert_own"
  ON public.ai_content FOR INSERT TO authenticated
  WITH CHECK ((SELECT auth.uid())::text = user_id);

CREATE POLICY "ai_content_update_own"
  ON public.ai_content FOR UPDATE TO authenticated
  USING ((SELECT auth.uid())::text = user_id)
  WITH CHECK ((SELECT auth.uid())::text = user_id);

CREATE POLICY "ai_content_delete_own"
  ON public.ai_content FOR DELETE TO authenticated
  USING ((SELECT auth.uid())::text = user_id);

-- Policies: billing orders/refunds/events/med-safety
DROP POLICY IF EXISTS "billing_orders_select_own" ON public.billing_orders;
CREATE POLICY "billing_orders_select_own"
  ON public.billing_orders FOR SELECT TO authenticated
  USING ((SELECT auth.uid())::text = user_id);

DROP POLICY IF EXISTS "billing_refund_requests_select_own" ON public.billing_refund_requests;
DROP POLICY IF EXISTS "billing_refund_requests_insert_own" ON public.billing_refund_requests;
DROP POLICY IF EXISTS "billing_refund_requests_update_own" ON public.billing_refund_requests;

CREATE POLICY "billing_refund_requests_select_own"
  ON public.billing_refund_requests FOR SELECT TO authenticated
  USING ((SELECT auth.uid())::text = user_id);

CREATE POLICY "billing_refund_requests_insert_own"
  ON public.billing_refund_requests FOR INSERT TO authenticated
  WITH CHECK ((SELECT auth.uid())::text = user_id);

CREATE POLICY "billing_refund_requests_update_own"
  ON public.billing_refund_requests FOR UPDATE TO authenticated
  USING ((SELECT auth.uid())::text = user_id)
  WITH CHECK ((SELECT auth.uid())::text = user_id);

DROP POLICY IF EXISTS "billing_refund_events_select_own" ON public.billing_refund_events;
CREATE POLICY "billing_refund_events_select_own"
  ON public.billing_refund_events FOR SELECT TO authenticated
  USING ((SELECT auth.uid())::text = user_id);

DROP POLICY IF EXISTS "med_safety_usage_events_select_own" ON public.med_safety_usage_events;
CREATE POLICY "med_safety_usage_events_select_own"
  ON public.med_safety_usage_events FOR SELECT TO authenticated
  USING ((SELECT auth.uid())::text = user_id);

-- 13) Grants (explicit for clean databases)
GRANT USAGE ON SCHEMA public TO anon, authenticated, service_role;

GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.rnest_users TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.rnest_user_state TO authenticated;
GRANT SELECT ON TABLE public.rnest_user_state_revisions TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.ai_content TO authenticated;
GRANT SELECT ON TABLE public.billing_orders TO authenticated;
GRANT SELECT, INSERT, UPDATE ON TABLE public.billing_refund_requests TO authenticated;
GRANT SELECT ON TABLE public.billing_refund_events TO authenticated;
GRANT SELECT ON TABLE public.med_safety_usage_events TO authenticated;

GRANT USAGE, SELECT ON SEQUENCE public.rnest_user_state_revisions_id_seq TO authenticated;
GRANT USAGE, SELECT ON SEQUENCE public.billing_refund_requests_id_seq TO authenticated;
GRANT USAGE, SELECT ON SEQUENCE public.billing_refund_events_id_seq TO authenticated;
GRANT USAGE, SELECT ON SEQUENCE public.med_safety_usage_events_id_seq TO authenticated;

-- 14) Admin-friendly views
CREATE VIEW public.v_user_data_overview AS
SELECT
  u.user_id,
  u.created_at,
  u.updated_at AS user_updated_at,
  u.last_seen,
  u.subscription_tier,
  u.subscription_status,
  u.subscription_current_period_end,
  u.med_safety_extra_credits,
  u.med_safety_daily_used,
  u.med_safety_usage_date,
  s.updated_at AS state_updated_at,
  CASE
    WHEN jsonb_typeof(s.payload -> 'schedule') = 'object'
      THEN (SELECT count(*)::integer FROM jsonb_object_keys(s.payload -> 'schedule') AS _k)
    ELSE 0
  END AS schedule_days,
  CASE
    WHEN jsonb_typeof(s.payload -> 'notes') = 'object'
      THEN (SELECT count(*)::integer FROM jsonb_object_keys(s.payload -> 'notes') AS _k)
    ELSE 0
  END AS note_days,
  CASE
    WHEN jsonb_typeof(s.payload -> 'emotions') = 'object'
      THEN (SELECT count(*)::integer FROM jsonb_object_keys(s.payload -> 'emotions') AS _k)
    ELSE 0
  END AS emotion_days,
  CASE
    WHEN jsonb_typeof(s.payload -> 'bio') = 'object'
      THEN (SELECT count(*)::integer FROM jsonb_object_keys(s.payload -> 'bio') AS _k)
    ELSE 0
  END AS bio_days,
  a.updated_at AS ai_updated_at,
  a.date_iso AS ai_date_iso
FROM public.rnest_users u
LEFT JOIN public.rnest_user_state s ON s.user_id = u.user_id
LEFT JOIN public.ai_content a ON a.user_id = u.user_id;

CREATE VIEW public.v_user_billing_summary AS
SELECT
  u.user_id,
  coalesce(sum(case when o.status = 'DONE' then o.amount else 0 end), 0)::bigint AS paid_amount_total,
  coalesce(sum(case when o.status = 'DONE' and o.order_kind = 'credit_pack' then o.credit_pack_units else 0 end), 0)::bigint AS credit_units_bought_total,
  coalesce(sum(case when o.status = 'DONE' and o.order_kind = 'subscription' then 1 else 0 end), 0)::bigint AS subscription_paid_count,
  max(o.created_at) AS latest_order_at
FROM public.rnest_users u
LEFT JOIN public.billing_orders o ON o.user_id = u.user_id
GROUP BY u.user_id;

CREATE VIEW public.v_user_credit_live AS
WITH credit_base AS (
  SELECT
    u.user_id,
    u.subscription_tier,
    u.subscription_status,
    u.subscription_current_period_end,
    greatest(0, u.med_safety_extra_credits) AS extra_credits,
    greatest(0, u.med_safety_daily_used) AS daily_used_raw,
    u.med_safety_usage_date,
    (now() AT TIME ZONE 'Asia/Seoul')::date AS kst_today
  FROM public.rnest_users u
)
SELECT
  b.user_id,
  (
    b.subscription_tier = 'pro'
    AND b.subscription_status = 'active'
    AND (b.subscription_current_period_end IS NULL OR b.subscription_current_period_end > now())
  ) AS is_pro_active,
  CASE
    WHEN (
      b.subscription_tier = 'pro'
      AND b.subscription_status = 'active'
      AND (b.subscription_current_period_end IS NULL OR b.subscription_current_period_end > now())
    ) THEN 10
    ELSE 0
  END AS daily_limit,
  CASE
    WHEN b.med_safety_usage_date = b.kst_today THEN b.daily_used_raw
    ELSE 0
  END AS daily_used,
  CASE
    WHEN (
      b.subscription_tier = 'pro'
      AND b.subscription_status = 'active'
      AND (b.subscription_current_period_end IS NULL OR b.subscription_current_period_end > now())
    ) THEN greatest(
      0,
      10 - CASE WHEN b.med_safety_usage_date = b.kst_today THEN b.daily_used_raw ELSE 0 END
    )
    ELSE 0
  END AS daily_remaining,
  b.extra_credits,
  (
    CASE
      WHEN (
        b.subscription_tier = 'pro'
        AND b.subscription_status = 'active'
        AND (b.subscription_current_period_end IS NULL OR b.subscription_current_period_end > now())
      ) THEN greatest(
        0,
        10 - CASE WHEN b.med_safety_usage_date = b.kst_today THEN b.daily_used_raw ELSE 0 END
      )
      ELSE 0
    END
    + b.extra_credits
  ) AS total_remaining,
  b.med_safety_usage_date,
  b.kst_today AS kst_today
FROM credit_base b;

GRANT SELECT ON TABLE public.v_user_data_overview TO authenticated;
GRANT SELECT ON TABLE public.v_user_billing_summary TO authenticated;
GRANT SELECT ON TABLE public.v_user_credit_live TO authenticated;

COMMENT ON TABLE public.rnest_users IS 'RNest 사용자 기본 상태/구독/크레딧 요약';
COMMENT ON TABLE public.rnest_user_state IS 'RNest 사용자 기록 스냅샷(캘린더/노트/감정/바이오)';
COMMENT ON TABLE public.rnest_user_state_revisions IS 'RNest 사용자 상태 변경 이력(복구/감사)';
COMMENT ON TABLE public.ai_content IS 'AI 분석 결과 캐시';
COMMENT ON TABLE public.billing_orders IS '결제 주문 원장';
COMMENT ON TABLE public.billing_refund_requests IS '환불 요청 상태';
COMMENT ON TABLE public.billing_refund_events IS '환불 상태 전이 이벤트';
COMMENT ON TABLE public.med_safety_usage_events IS 'AI 검색 크레딧 차감/복원 이력';
COMMENT ON VIEW public.v_user_data_overview IS '유저별 상태 저장 현황 요약 뷰';
COMMENT ON VIEW public.v_user_billing_summary IS '유저별 누적 결제/크레딧 구매 요약 뷰';
COMMENT ON VIEW public.v_user_credit_live IS '유저별 실시간 크레딧 잔여량 계산 뷰(KST 기준)';

SELECT pg_notify('pgrst', 'reload schema');

commit;
