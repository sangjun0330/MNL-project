CREATE TABLE IF NOT EXISTS public.shop_products (
  id text PRIMARY KEY,
  name text NOT NULL,
  subtitle text NOT NULL DEFAULT '',
  description text NOT NULL DEFAULT '',
  category text NOT NULL,
  visual_label text NOT NULL,
  visual_class text NOT NULL,
  price_label text NOT NULL DEFAULT '',
  partner_label text NOT NULL DEFAULT '',
  partner_status text NOT NULL DEFAULT '',
  external_url text NULL,
  price_krw integer NULL,
  checkout_enabled boolean NOT NULL DEFAULT false,
  benefit_tags text[] NOT NULL DEFAULT '{}'::text[],
  use_moments text[] NOT NULL DEFAULT '{}'::text[],
  caution text NOT NULL DEFAULT '',
  priority integer NOT NULL DEFAULT 0,
  match_signals text[] NOT NULL DEFAULT '{}'::text[],
  active boolean NOT NULL DEFAULT true,
  created_at timestamptz NOT NULL DEFAULT timezone('utc', now()),
  updated_at timestamptz NOT NULL DEFAULT timezone('utc', now())
);

CREATE TABLE IF NOT EXISTS public.shop_orders (
  order_id text PRIMARY KEY,
  user_id uuid NOT NULL,
  status text NOT NULL DEFAULT 'READY',
  product_id text NOT NULL,
  product_snapshot jsonb NOT NULL DEFAULT '{}'::jsonb,
  amount integer NOT NULL,
  currency text NOT NULL DEFAULT 'KRW',
  payment_key text NULL,
  payment_summary jsonb NULL,
  approved_at timestamptz NULL,
  fail_code text NULL,
  fail_message text NULL,
  refund_status text NOT NULL DEFAULT 'none',
  refund_reason text NULL,
  refund_requested_at timestamptz NULL,
  refund_reviewed_at timestamptz NULL,
  refund_reviewed_by uuid NULL,
  refund_note text NULL,
  refund_cancel_amount integer NULL,
  refund_canceled_at timestamptz NULL,
  refund_summary jsonb NULL,
  created_at timestamptz NOT NULL DEFAULT timezone('utc', now()),
  updated_at timestamptz NOT NULL DEFAULT timezone('utc', now())
);

CREATE TABLE IF NOT EXISTS public.shop_order_events (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  order_id text NOT NULL REFERENCES public.shop_orders(order_id) ON DELETE CASCADE,
  user_id uuid NOT NULL,
  actor_user_id uuid NULL,
  actor_role text NOT NULL DEFAULT 'system',
  event_type text NOT NULL,
  status text NOT NULL,
  message text NULL,
  metadata jsonb NULL,
  created_at timestamptz NOT NULL DEFAULT timezone('utc', now())
);

CREATE INDEX IF NOT EXISTS idx_shop_products_active_priority
  ON public.shop_products (active, priority DESC, updated_at DESC);

CREATE INDEX IF NOT EXISTS idx_shop_orders_user_updated
  ON public.shop_orders (user_id, updated_at DESC);

CREATE INDEX IF NOT EXISTS idx_shop_orders_status_updated
  ON public.shop_orders (status, updated_at DESC);

CREATE INDEX IF NOT EXISTS idx_shop_order_events_order_created
  ON public.shop_order_events (order_id, created_at DESC);

ALTER TABLE public.shop_products ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.shop_orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.shop_order_events ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS shop_products_public_read ON public.shop_products;
CREATE POLICY shop_products_public_read
  ON public.shop_products
  FOR SELECT
  USING (active = true);

DROP POLICY IF EXISTS shop_orders_owner_read ON public.shop_orders;
CREATE POLICY shop_orders_owner_read
  ON public.shop_orders
  FOR SELECT
  USING (auth.uid() IS NOT NULL AND auth.uid() = user_id);

DROP POLICY IF EXISTS shop_order_events_owner_read ON public.shop_order_events;
CREATE POLICY shop_order_events_owner_read
  ON public.shop_order_events
  FOR SELECT
  USING (auth.uid() IS NOT NULL AND auth.uid() = user_id);

DROP TRIGGER IF EXISTS trg_set_updated_at_shop_products ON public.shop_products;
CREATE TRIGGER trg_set_updated_at_shop_products
  BEFORE UPDATE ON public.shop_products
  FOR EACH ROW EXECUTE FUNCTION public.tg_set_updated_at();

DROP TRIGGER IF EXISTS trg_set_updated_at_shop_orders ON public.shop_orders;
CREATE TRIGGER trg_set_updated_at_shop_orders
  BEFORE UPDATE ON public.shop_orders
  FOR EACH ROW EXECUTE FUNCTION public.tg_set_updated_at();

INSERT INTO public.shop_products (
  id,
  name,
  subtitle,
  description,
  category,
  visual_label,
  visual_class,
  price_label,
  partner_label,
  partner_status,
  external_url,
  price_krw,
  checkout_enabled,
  benefit_tags,
  use_moments,
  caution,
  priority,
  match_signals,
  active
)
SELECT
  COALESCE(NULLIF(item->>'id', ''), md5(item::text)),
  COALESCE(item->>'name', ''),
  COALESCE(item->>'subtitle', ''),
  COALESCE(item->>'description', ''),
  COALESCE(item->>'category', 'recovery'),
  COALESCE(item->>'visualLabel', COALESCE(item->>'name', '상품')),
  COALESCE(item->>'visualClass', ''),
  COALESCE(item->>'priceLabel', ''),
  COALESCE(item->>'partnerLabel', ''),
  COALESCE(item->>'partnerStatus', ''),
  NULLIF(item->>'externalUrl', ''),
  CASE WHEN COALESCE(item->>'priceKrw', '') <> '' THEN (item->>'priceKrw')::integer ELSE NULL END,
  COALESCE((item->>'checkoutEnabled')::boolean, false),
  CASE
    WHEN jsonb_typeof(item->'benefitTags') = 'array'
      THEN ARRAY(SELECT jsonb_array_elements_text(item->'benefitTags'))
    ELSE '{}'::text[]
  END,
  CASE
    WHEN jsonb_typeof(item->'useMoments') = 'array'
      THEN ARRAY(SELECT jsonb_array_elements_text(item->'useMoments'))
    ELSE '{}'::text[]
  END,
  COALESCE(item->>'caution', ''),
  COALESCE(NULLIF(item->>'priority', '')::integer, 0),
  CASE
    WHEN jsonb_typeof(item->'matchSignals') = 'array'
      THEN ARRAY(SELECT jsonb_array_elements_text(item->'matchSignals'))
    ELSE '{}'::text[]
  END,
  true
FROM public.ai_content ac
CROSS JOIN LATERAL jsonb_array_elements(
  CASE
    WHEN jsonb_typeof(ac.data->'products') = 'array' THEN ac.data->'products'
    ELSE '[]'::jsonb
  END
) AS item
WHERE ac.user_id = '__system_shop_catalog__'
  AND ac.data->>'type' = 'shop_catalog'
ON CONFLICT (id) DO NOTHING;

INSERT INTO public.shop_orders (
  order_id,
  user_id,
  status,
  product_id,
  product_snapshot,
  amount,
  currency,
  payment_key,
  payment_summary,
  approved_at,
  fail_code,
  fail_message,
  refund_status,
  refund_reason,
  refund_requested_at,
  refund_reviewed_at,
  refund_reviewed_by,
  refund_note,
  refund_cancel_amount,
  refund_canceled_at,
  refund_summary,
  created_at,
  updated_at
)
SELECT
  src.order_payload->>'orderId',
  (src.order_payload->>'userId')::uuid,
  COALESCE(NULLIF(src.order_payload->>'status', ''), 'READY'),
  COALESCE(src.order_payload->>'productId', ''),
  CASE WHEN jsonb_typeof(src.order_payload->'productSnapshot') = 'object' THEN src.order_payload->'productSnapshot' ELSE '{}'::jsonb END,
  COALESCE(NULLIF(src.order_payload->>'amount', '')::integer, 0),
  COALESCE(NULLIF(src.order_payload->>'currency', ''), 'KRW'),
  NULLIF(src.order_payload->>'paymentKey', ''),
  CASE WHEN jsonb_typeof(src.order_payload->'tossResponse') IN ('object', 'array') THEN src.order_payload->'tossResponse' ELSE NULL END,
  NULLIF(src.order_payload->>'approvedAt', '')::timestamptz,
  NULLIF(src.order_payload->>'failCode', ''),
  NULLIF(src.order_payload->>'failMessage', ''),
  COALESCE(NULLIF(src.refund_payload->>'status', ''), 'none'),
  NULLIF(src.refund_payload->>'reason', ''),
  NULLIF(src.refund_payload->>'requestedAt', '')::timestamptz,
  NULLIF(src.refund_payload->>'reviewedAt', '')::timestamptz,
  NULLIF(src.refund_payload->>'reviewedBy', '')::uuid,
  NULLIF(src.refund_payload->>'note', ''),
  CASE WHEN COALESCE(src.refund_payload->>'cancelAmount', '') <> '' THEN (src.refund_payload->>'cancelAmount')::integer ELSE NULL END,
  NULLIF(src.refund_payload->>'canceledAt', '')::timestamptz,
  CASE WHEN jsonb_typeof(src.refund_payload->'cancelResponse') IN ('object', 'array') THEN src.refund_payload->'cancelResponse' ELSE NULL END,
  COALESCE(NULLIF(src.order_payload->>'createdAt', '')::timestamptz, COALESCE(ac.created_at, timezone('utc', now()))),
  COALESCE(NULLIF(src.order_payload->>'updatedAt', '')::timestamptz, COALESCE(ac.updated_at, timezone('utc', now())))
FROM public.ai_content ac
CROSS JOIN LATERAL (
  SELECT
    CASE WHEN jsonb_typeof(ac.data->'order') = 'object' THEN ac.data->'order' ELSE '{}'::jsonb END AS order_payload,
    CASE WHEN jsonb_typeof(ac.data->'order'->'refund') = 'object' THEN ac.data->'order'->'refund' ELSE '{}'::jsonb END AS refund_payload
) AS src
WHERE ac.user_id LIKE '\_\_shop\_order\_%' ESCAPE '\'
  AND ac.data->>'type' = 'shop_order'
  AND COALESCE(src.order_payload->>'orderId', '') <> ''
  AND COALESCE(src.order_payload->>'userId', '') <> ''
ON CONFLICT (order_id) DO NOTHING;

INSERT INTO public.shop_order_events (
  order_id,
  user_id,
  actor_role,
  event_type,
  status,
  message,
  metadata,
  created_at
)
SELECT
  so.order_id,
  so.user_id,
  'system',
  'legacy_import',
  so.status,
  'ai_content에서 shop_orders로 이관된 주문입니다.',
  NULL,
  so.created_at
FROM public.shop_orders so
WHERE NOT EXISTS (
  SELECT 1
  FROM public.shop_order_events ev
  WHERE ev.order_id = so.order_id
    AND ev.event_type = 'legacy_import'
);
